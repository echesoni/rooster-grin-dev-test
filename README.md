# Rooster Grin Developer Test
This repository shows my work on the Rooster Grin front-end developer test.
See the website at: https://serene-hamlet-57720.herokuapp.com/


#### Technologies Used to Create this App:
- Node.js
- Express
- Sass
- Materialize

##### Reasons for Using Specified Tools:
- Node.js is a JavaScript runtime that uses the V8 engine developed by Google for use in Chrome. Some of the main reasons why I like using node include the fact that;
1. It is fast
2. Node's package manager (npm) has a great community. Npm's ecosystem is robust, consistent, and simple (i.e. or at the very least; complexities are hidden so it's pretty easy to use).
3. Node has a great community! (There are plenty of node meetups one can attend to learn some new tips and tricks).

- Express is a lightweight web application framework to help organize your web application into an MVC architecture on the server side. Although it was not critical to use express while developing the Rooster Grin front-end, I do use __node + express__ together frequently in other projects, and I like to get in the habit of using both to structure in my "index.js".

- Sass is a css pre-processor that allows you leverage basic programming to write clean and concise css. By using mixins and variables, I am able to reduce the amount of time spent writing css/stying a particular page, and reduce styling errors.

- Materialize is a design language written by Google. I've used material in the past and I like the look and feel of the library's design patterns. Using materialize allows me to quickly create and piece together various design elements in my applications.

#### Struggles Faced While Working on the Project
It was tricky leveraging both CSS Grid Layout and Flexbox. I had the most trouble balancing the two when desiging the part of the page containing the four icons, but after some tinkering, I was able to find a solution.

#### What I Enjoyed the Most
I enjoyed the planning and the process a lot. As I learn more about development, it becomes easier for me to develop a plan before I start building an application, and stick to that plan as a progress through the project. Of course, it is necessary to be flexible, and sometimes adjust the plan, but it is also really cool to come across familiar "speed bumps"/situations and know how to adjust. Having a plan also helps me remain calm when I don't know the solution. I know that I started at point A and I'd like to finish at point B. I may not know exactly what path I'll take to get me from point A to point B, but as long as I know where I'm headed -- I'll get there :grin:
